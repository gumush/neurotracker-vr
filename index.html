<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NeuroTracker VR</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
  import { VRButton } from 'https://unpkg.com/three@0.161.0/examples/jsm/webxr/VRButton.js';

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x202020);

  const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.z = 5;

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));

  const light = new THREE.PointLight(0xffffff, 1);
  light.position.set(10, 10, 10);
  scene.add(light);

  const spheres = [];
  const velocities = [];
  const targetIndices = [];
  const numTargets = 3;
  const sphereGroup = new THREE.Group();
  scene.add(sphereGroup);

  for (let i = 0; i < 8; i++) {
    const geometry = new THREE.SphereGeometry(0.2, 32, 32);
    const material = new THREE.MeshStandardMaterial({ color: 0x0000ff });
    const sphere = new THREE.Mesh(geometry, material);
    sphere.position.set(
      THREE.MathUtils.randFloatSpread(4),
      THREE.MathUtils.randFloatSpread(4),
      THREE.MathUtils.randFloatSpread(4)
    );
    sphere.name = `Sphere_${i}`;
    spheres.push(sphere);
    sphereGroup.add(sphere);

    const velocity = new THREE.Vector3(
      THREE.MathUtils.randFloatSpread(0.02),
      THREE.MathUtils.randFloatSpread(0.02),
      THREE.MathUtils.randFloatSpread(0.02)
    );
    velocities.push(velocity);
  }

  while (targetIndices.length < numTargets) {
    const rand = Math.floor(Math.random() * spheres.length);
    if (!targetIndices.includes(rand)) {
      targetIndices.push(rand);
      spheres[rand].material.color.set(0xffff00);
    }
  }

  setTimeout(() => {
    for (let i of targetIndices) {
      spheres[i].material.color.set(0x0000ff);
    }
  }, 2000);

  let moving = true;
  setTimeout(() => {
    moving = false;
    console.log("Now select targets");
  }, 8000);

  const controller = renderer.xr.getController(0);
  scene.add(controller);

  const raycaster = new THREE.Raycaster();
  const tempMatrix = new THREE.Matrix4();
  let selected = [];

  controller.addEventListener('select', () => {
    if (!moving) {
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

      const intersects = raycaster.intersectObjects(spheres);
      if (intersects.length > 0) {
        const obj = intersects[0].object;
        if (!selected.includes(obj.name)) {
          selected.push(obj.name);
          obj.material.color.set(0x00ff00);
          console.log(`Seçildi: ${obj.name}`);
        }

        if (selected.length === numTargets) {
          const correct = selected.filter(name =>
            targetIndices.includes(parseInt(name.split("_")[1]))
          );
          console.log(`Doğru sayısı: ${correct.length}/${numTargets}`);
        }
      }
    }
  });

  renderer.setAnimationLoop(() => {
    if (moving) {
      spheres.forEach((sphere, i) => {
        sphere.position.add(velocities[i]);
        for (let axis of ['x', 'y', 'z']) {
          if (Math.abs(sphere.position[axis]) > 4) {
            velocities[i][axis] *= -1;
          }
        }
      });
    }
    renderer.render(scene, camera);
  });
</script>
</body>
</html>